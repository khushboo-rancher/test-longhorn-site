<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Longhorn Manual Test Cases
    </title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
  </head>
  <body class="markdown-body" style="display: flex; padding: 1%;">
    
<aside style="width: 30%; padding: 1%; border-right: 1px solid lightgray;">
  <a href="https://longhorn.github.io/longhorn-tests/manual"><h2>Manual Test Cases</h2></a>
  
  <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/">End-to-end test cases</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/deployment/"> Deployment of Longhorn  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/ui/">UI  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/volume/">Volume  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/high-availability/">High Availability  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/kubernetes/">Kubernetes  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/backup/">Backup  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/node/">Node  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/scheduling/">Scheduling  </a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/end-to-end-test-cases/upgrade/">Upgrade  </a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/">Pre-release tests</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/air-gap/">Air Gap</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/air-gap/air-gap-installation/">Air gap installation</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/air-gap/air-gap-instance-manager-name/">Air gap installation with an instance-manager-image name longer than 63 characters</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/">Backup &amp; Restore tests</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/dr-volume-live-upgrade-and-rebuild/">#1279 DR volume live upgrade and rebuild</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/concurrent-backup-creation-deletion/">#1326 concurrent backup creation &amp; deletion</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/concurrent-backup/">#1341 concurrent backup test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/restore-volume-node-down/">#1355 The node the restore volume attached to is down</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/dr-volume-node-rebooted/">#1366 &amp;&amp; #1328 The node the DR volume attached to is rebooted</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/google-cloud-s3-interop-backups/">#1404 test backup functionality on google cloud and other s3 interop providers.</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/backup-and-restore/backup-block-deletion/">#1431 backup block deletion test</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/basic-operations-parallelism/">Basic operations parallelism</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/basic-operations-parallelism/snapshot-while-writing-data/">Snapshot while writing data in the volume</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/cluster-restore/">Cluster Restore</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/cluster-restore/system-upgrade-with-restore/">Longhorn system upgrade with restore</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/cluster-restore/node-creation-deletion-with-restore/">Node creation and deletion with restore</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/cluster-restore/recover-volumes-after-restore/">Recover Longhorn volumes after Rancher cluster restore</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/environment/">Environment</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/environment/cluster-using-customized-kubelet-root-directory/">Cluster using customize kubelet root directory</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/environment/k3s-selinux-compatibility/">Compatibility with k3s and SELinux</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/environment/rke2-cis-1.5-profile/">Test Longhorn Deployment on RKE2 with CIS-1.5 profile</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/">HA</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/backing-image-error-reporting-and-retry/">Backing Image Error Reporting and Retry</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/disk-migration-in-aws-asg/">Disk migration in AWS ASG</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/partial-engine-deployment/">Longhorn with engine is not deployed on all the nodes</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/replica-rebuilding/">Replica Rebuilding</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/ha/single-replica-node-down/">Single replica node down</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/">Node</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/backing-image-on-a-down-node/">Backing Image on a down node</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/degraded-availability/">Degraded availability with added nodes</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/improve-node-failure-handling/">Improve Node Failure Handling By Automatically Force Delete Terminating Pods of StatefulSet/Deployment On Downed Node</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/node-disconnection/">Node disconnection test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/node-drain-deletion/">Node drain and deletion test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/physical-node-down/">Physical node down</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/kubelet-restart-on-a-node/">Test kubelet restart on a node of the cluster</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/node/node-deletion/">Test node deletion</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/resiliency/">Resiliency</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/resiliency/simulated-slow-disk/">#2206 Fix the spinning disk on Longhorn</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/resiliency/timeout/">Test timeout on loss of network connectivity</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/stability/">Stability</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/stability/multiple-installation/">Longhorn installation multiple times</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/stress/backup-listing/">Test backup listing S3/NFS</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/uninstallation/uninstallation-checks/">Uninstallation Checks</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/">Upgrade</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/auto-upgrade-engine/">Automatically Upgrading Longhorn Engine Test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/kubernetes-upgrade-test/">Kubernetes upgrade test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/longhorn-upgrade-test/">Longhorn Upgrade test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/update_csi_components_when_images_change/">Re-deploy CSI components when their images change</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/backing-image-during-upgrade/">Test Backing Image during Longhorn upgrade</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/engine-crash-during-live-upgrade/">Test Engine Crash During Live Upgrade</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/upgrade-with-new-instance-manager/">Test System Upgrade with New Instance Manager</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/pre-release/upgrade/upgrade-conflict-handling/">Upgrade Conflict Handling test</a></li>
  

</ul>

  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/">Release specific tests</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/">v1.0.0</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/new-node-custom-data-directory/">New Node with Custom Data Directory</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/suse-sles12sp3/">Operating System specific tests for SUSE SLES12SP3</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/suse-sles12sp3/ext4-custom-fs-params-1/">Testing ext4 with custom fs params1 (no 64bit, no metadata_csum)</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/suse-sles12sp3/ext4-custom-fs-params-2/">Testing ext4 with custom fs params2 (no metadata_csum)</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/suse-sles12sp3/ext4-no-custom-fs-params/">Testing ext4 without custom fs params</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.0/suse-sles12sp3/xfs-after-custom-fs-params/">Testing xfs after custom fs params (xfs should ignore the custom fs params)</a></li>
  

</ul>

  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/">v1.0.1</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/besteffort-recurring-job/">BestEffort Recurring Job Cleanup</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/change-imagepullpolicy/">Change imagePullPolicy to IfNotPresent Test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/dr-volume-latest-backup-deletion/">DR volume related latest backup deletion test</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/nfsv4-enforcement/">NFSv4 Enforcement (No NFSv3 Fallback)</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/priorityclass-default-setting/">Priority Class Default Setting</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/error-fail-remount/">Return an error when fail to remount a volume</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/test-s3-access-style/">Test access style for S3 compatible backupstore</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/test-s3-backupstore/">Test S3 backupstore in a cluster sitting behind a Http Proxy</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.1/ui-volume-deletion/">Volume Deletion UI Warnings</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.2/">v1.0.2</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.0.2/upgrade-lease-lock/">Upgrade Lease Lock</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/">v1.1.0</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/prometheus_support/">Prometheus Support</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/recurring-backup-job-interruptions/">Recurring backup job interruptions</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/reusing-failed-replica-for-rebuilding/">Reusing failed replica for rebuilding</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/kubelet_volume_metrics/">Support Kubelet Volume Metrics</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/additional-printer-columns/">Test Additional Printer Columns</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/instance-manager-ip-sync/">Test Instance Manager IP Sync</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/iscsi_installation/">Test ISCSI Installation on EKS</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/rwx_feature/">Test Read Write Many Feature</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/uninstallation/">Test uninstallation</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.0/upgrade_with_modified_storageclass/">Upgrade Longhorn with modified Storage Class</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/">v1.1.1</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/csi-sanity-check/">CSI Sanity Check</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/partial-engine-deployment/">Longhorn with engine is not deployed on all the nodes</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/tolerations_priorityclass_setting/">Set Tolerations/PriorityClass For System Components</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/disable_ipv6/">Test Disable IPv6</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/test-file-sync-cancellation/">Test File Sync Cancellation</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/ws-traffic-flood/">Test Frontend Traffic</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/delete-node/">Test Node Delete</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/test-node-selector/">Test Node Selector</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/rwx-mount-ownership-reset/">Test RWX share-mount ownership reset</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/test-service-account-mount/">Test Service Account mount on host</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/snapshot-purge-error-handling/">Test Snapshot Purge Error Handling</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.1/system-upgrade-with-deprecated-cpu-setting/">Test system upgrade with the deprecated CPU setting</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.2/">v1.1.2</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.2/delete-cronjob-for-detached-volumes/">Test CronJob For Volumes That Are Detached For A Long Time</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.2/full-ws-data-tranfer-when-no-updates/">Test Frontend Web-socket Data Transfer When Resource Not Updated</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.1.2/instance-manager-streaming-connection-recovery/">Test Instance Manager Streaming Connection Recovery</a></li>
  

</ul>

  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/">v1.2.0</a></li>
  
    <ul>

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/test-backing-image-upload/">Test backing image</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/backup-creation-with-old-engine-image/">Test Backup Creation With Old Engine Image</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/test-instance-manager-cleanup-during-uninstall/">Test instance manager cleanup during uninstall</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/label-driven-recurring-job/">Test Label-driven Recurring Job</a></li>
  

  <li><a href="https://longhorn.github.io/longhorn-tests/manual/release-specific/v1.2.0/test_version_bump/">Test Version Bump of Kubernetes, API version group, CSI component&rsquo;s dependency version</a></li>
  

</ul>

  

</ul>

  

</ul>

  
</aside>

<main style="padding: 1%; width: 70%;">
  <h1 id="title"><ol start="5">
<li>Kubernetes</li>
</ol>
</h1>
  <div>
    <article id="content">
       <h3 id="dynamic-provisioning-with-storageclass">Dynamic provisioning with StorageClass</h3>
<ol>
<li>
<p>Can create and use volume using StorageClass</p>
</li>
<li>
<p>Can create a new StorageClass use new parameters and it will take effect on the volume created by the storage class.</p>
</li>
<li>
<p>If the PV reclaim policy is delete, once PVC and PV are deleted, Longhorn volume should be deleted.</p>
</li>
</ol>
<h3 id="static-provisioning-using-longhorn-created-pvpvc">Static provisioning using Longhorn created PV/PVC</h3>
<ol>
<li>
<p>PVC can be used by the new workload</p>
</li>
<li>
<p>Delete the PVC will not result in PV deletion</p>
</li>
<li>
<p>Delete the PV will not result in Longhorn volume deletion and data loss.</p>
</li>
</ol>
<h2 id="automation-tests">Automation Tests</h2>
<table>
<thead>
<tr>
<th><strong>#</strong></th>
<th><strong>Test name</strong></th>
<th><strong>Description</strong></th>
<th><strong>Tags</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test_storage_class_from_backup</td>
<td>Test restore backup using StorageClass<br><br>1.  Create volume and PV/PVC/POD<br>2.  Write <code>test_data</code> into pod<br>3.  Create a snapshot and back it up. Get the backup URL<br>4.  Create a new StorageClass <code>longhorn-from-backup</code> and set backup URL.<br>5.  Use <code>longhorn-from-backup</code> to create a new PVC<br>6.  Wait for the volume to be created and complete the restoration.<br>7.  Create the pod using the PVC. Verify the data</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>2</td>
<td>test_pv_creation</td>
<td>Test creating PV using Longhorn API<br><br>1.  Create volume<br>2.  Create PV for the volume<br>3.  Try to create another PV for the same volume. It should fail.<br>4.  Check Kubernetes Status for the volume since PV is created.</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>3</td>
<td>test_pvc_creation_with_default_sc_set</td>
<td>Test creating PVC with default StorageClass set<br><br>The target is to make sure the newly create PV/PVC won&rsquo;t use default StorageClass, and if there is no default StorageClass, PV/PVC can still be created.<br><br>1.  Create a StorageClass and set it to be the default StorageClass<br>2.  Update static StorageClass to <code>longhorn-static-test</code><br>3.  Create volume then PV/PVC.<br>4.  Make sure the newly created PV/PVC using StorageClass <code>longhorn-static-test</code><br>5.  Create pod with PVC.<br>6.  Verify volume&rsquo;s Kubernetes Status<br>7.  Remove PVC and Pod.<br>8.  Verify volume&rsquo;s Kubernetes Status only contains current PV and history<br>9.  Wait for volume to detach (since pod is deleted)<br>10.  Reuse the volume on a new pod. Wait for the pod to start<br>11.  Verify volume&rsquo;s Kubernetes Status reflect the new pod.<br>12.  Delete PV/PVC/Pod.<br>13.  Verify volume&rsquo;s Kubernetes Status only contains history<br>14.  Delete the default StorageClass.<br>15.  Create PV/PVC for the volume.<br>16.  Make sure the PV&rsquo;s StorageClass is static StorageClass</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>4</td>
<td>test_provisioner_io</td>
<td>Test that input and output on a StorageClass provisioned PersistentVolumeClaim works as expected.<br><br>Fixtures are torn down here in reverse order that they are specified as a parameter. Take caution when reordering test fixtures.<br><br>1.  Create a StorageClass, PVC and Pod.<br>2.  Wait for pod to be up.<br>3.  Write data to the pod<br>4.  Delete the original pod and create a new one using the same PVC<br>5.  Read the data from the new pod, verify the data.</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>5</td>
<td>test_provisioner_mount</td>
<td>Test that a StorageClass provisioned volume can be created, mounted, unmounted, and deleted properly on the Kubernetes cluster.<br><br>Fixtures are torn down here in reverse order that they are specified as a parameter. Take caution when reordering test fixtures.<br><br>1.  Create a StorageClass, PVC and Pod<br>2.  Verify the pod is up and volume parameters.</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>6</td>
<td>test_provisioner_params</td>
<td>Test that substituting different StorageClass parameters is reflected in the resulting PersistentVolumeClaim.<br><br>Fixtures are torn down here in reverse order that they are specified as a parameter. Take caution when reordering test fixtures.<br><br>1.  Create a StorageClass with replica 2 (instead of 3) etc.<br>2.  Create PVC and Pod using it.<br>3.  Verify the volume&rsquo;s parameter matches the Storage Class.</td>
<td>Kubernetes</td>
</tr>
<tr>
<td>7</td>
<td>test_provisioner_tags</td>
<td>Test that a StorageClass can properly provision a volume with requested Tags.<br><br>1.  Use <code>node_default_tags</code> to add default tags to nodes.<br>2.  Create a StorageClass with disk and node tag set.<br>3.  Create PVC and Pod.<br>4.  Verify the volume has the correct parameters and tags.</td>
<td>Kubernetes<br><br>Scheduling: Tag</td>
</tr>
<tr>
<td>8</td>
<td>test_csi_backup</td>
<td>Test that backup/restore works with volumes created by CSI driver.<br><br>Run the test for all the backupstores<br><br>1.  Create PV/PVC/Pod using dynamic provisioned volume<br>2.  Write data and create snapshot using Longhorn API<br>3.  Verify the existence of backup<br>4.  Create another Pod using restored backup<br>5.  Verify the data in the new Pod</td>
<td>Kubernetes: CSI<br><br>Backup</td>
</tr>
<tr>
<td>9</td>
<td>test_csi_block_volume</td>
<td>Test CSI feature: raw block volume<br><br>1.  Create a PVC with <code>volumeMode = Block</code><br>2.  Create a pod using the PVC to dynamic provision a volume<br>3.  Verify the pod creation<br>4.  Generate <code>test_data</code> and write to the block volume directly in the pod<br>5.  Read the data back for validation<br>6.  Delete the pod and create <code>pod2</code> to use the same volume<br>7.  Validate the data in <code>pod2</code> is consistent with <code>test_data</code></td>
<td>Kubernetes: CSI</td>
</tr>
<tr>
<td>10</td>
<td>test_csi_io</td>
<td>Test that input and output on a statically defined CSI volume works as expected.<br><br>Note: Fixtures are torn down here in reverse order that they are specified as a parameter. Take caution when reordering test fixtures.<br><br>1.  Create PV/PVC/Pod with dynamic positioned Longhorn volume<br>2.  Generate <code>test_data</code> and write it to volume using the equivalent of <code>kubectl exec</code><br>3.  Delete the Pod<br>4.  Create another pod with the same PV<br>5.  Check the previous created <code>test_data</code> in the new Pod</td>
<td>Kubernetes: CSI</td>
</tr>
<tr>
<td>11</td>
<td>test_csi_mount</td>
<td>Test that a statically defined CSI volume can be created, mounted, unmounted, and deleted properly on the Kubernetes cluster.<br><br>Note: Fixtures are torn down here in reverse order that they are specified as a parameter. Take caution when reordering test fixtures.<br><br>1.  Create a PV/PVC/Pod with dynamic provisioned Longhorn volume<br>2.  Make sure the pod is running<br>3.  Verify the volume status</td>
<td>Kubernetes: CSI</td>
</tr>
<tr>
<td>12</td>
<td>test_csi_offline_expansion</td>
<td>Test CSI feature: offline expansion<br><br>1.  Create a new <code>storage_class</code> with <code>allowVolumeExpansion</code> set<br>2.  Create PVC and Pod with dynamic provisioned volume from the StorageClass<br>3.  Generate <code>test_data</code> and write to the pod<br>4.  Delete the pod<br>5.  Update pvc.spec.resources to expand the volume<br>6.  Verify the volume expansion done using Longhorn API<br>7.  Create a new pod and validate the volume content</td>
<td>Kubernetes: CSI<br><br>Volume: Expansion</td>
</tr>
<tr>
<td>13</td>
<td>test_xfs_pv</td>
<td>Test create PV with new XFS filesystem<br><br>1.  Create a volume<br>2.  Create a PV for the existing volume, specify <code>xfs</code> as filesystem<br>3.  Create PVC and Pod<br>4.  Make sure Pod is running.<br>5.  Write data into the pod and read back for validation.</td>
<td>Kubernetes: CSI</td>
</tr>
<tr>
<td>14</td>
<td>test_xfs_pv_existing_volume</td>
<td>Test create PV with existing XFS filesystem<br><br>1.  Create a volume<br>2.  Create PV/PVC for the existing volume, specify <code>xfs</code> as filesystem<br>3.  Attach the volume to the current node.<br>4.  Format it to <code>xfs</code><br>5.  Create a POD using the volume</td>
<td>Kubernetes: CSI</td>
</tr>
<tr>
<td>15</td>
<td>test_statefulset_backup</td>
<td>Test that backups on StatefulSet volumes work properly.<br><br>1.  Create a StatefulSet with VolumeClaimTemplate and Longhorn.<br>2.  Wait for pods to run.<br><br>Then create backup using following steps for each pod:<br><br>1.  Create a snapshot<br>2.  Write some data into it<br>3.  Create another snapshot <code>backup_snapshot</code><br>4.  Create a third snapshot<br>5.  Backup the snapshot <code>backup_snapshot</code><br>6.  Wait for backup to show up. 1 Verify the backup informations</td>
<td>Kubernetes: StatefulSet<br><br>Backup</td>
</tr>
<tr>
<td>16</td>
<td>test_statefulset_mount</td>
<td>Tests that volumes provisioned for a StatefulSet can be properly created, mounted, unmounted, and deleted on the Kubernetes cluster.<br><br>1.  Create a StatefulSet using dynamic provisioned Longhorn volume.<br>2.  Wait for pods to become running<br>3.  Check volume properites are consistent with the StorageClass</td>
<td>Kubernetes: StatefulSet</td>
</tr>
<tr>
<td>17</td>
<td>test_statefulset_pod_deletion</td>
<td>Test that a StatefulSet can spin up a new Pod with the same data after a previous Pod has been deleted.<br><br>1.  Create a StatefulSet with VolumeClaimTemplate and Longhorn.<br>2.  Wait for pods to run.<br>3.  Write some data to one of the pod.<br>4.  Delete that pod.<br>5.  Wait for the StatefulSet to recreate the pod<br>6.  Verify the data in the pod.</td>
<td>Kubernetes: StatefulSet</td>
</tr>
<tr>
<td>18</td>
<td>test_statefulset_recurring_backup</td>
<td>Test that recurring backups on StatefulSets work properly.<br><br>1.  Create a StatefulSet with VolumeClaimTemplate and Longhorn.<br>2.  Wait for pods to run.<br>3.  Write some data to every pod<br>4.  Schedule recurring jobs for volumes using Longhorn API<br>5.  Wait for 5 minutes<br>6.  Verify the snapshots created by the recurring jobs</td>
<td>Kubernetes: StatefulSet<br><br>Backup</td>
</tr>
<tr>
<td>19</td>
<td>test_statefulset_restore</td>
<td>Test that data can be restored into volumes usable by a StatefulSet.<br><br>1.  Create a StatefulSet with VolumeClaimTemplate and Longhorn.<br>2.  Wait for pods to run.<br>3.  Create a backup for each pod.<br>4.  Delete the StatefulSet, including the Longhorn volumes.<br>5.  Create volumes and PV/PVC using previous backups from each Pod.<br>    1.  PVs will be created using the previous names.<br>        <br>    2.  PVCs will be created using previous name + &ldquo;-2&rdquo; due to statefulset has a naming policy for what should be PVC name for them.<br>        <br>6.  Create a new StatefulSet using the previous name + &ldquo;-2&rdquo;<br>7.  Wait for pods to be up. . Verify the pods contain the previous backed up data</td>
<td>Kubernetes: StatefulSet<br><br>Backup</td>
</tr>
<tr>
<td>20</td>
<td>test_statefulset_scaling</td>
<td>Test that scaling up a StatefulSet successfully provisions new volumes.<br><br>1.  Create a StatefulSet with VolumeClaimTemplate and Longhorn.<br>2.  Wait for pods to run.<br>3.  Verify the properities of volumes.<br>4.  Scale the StatefulSet to 3 replicas<br>5.  Wait for the new pod to become ready.<br>6.  Verify the new volume properties.</td>
<td>Kubernetes: StatefulSet</td>
</tr>
<tr>
<td>21</td>
<td>test_toleration_setting</td>
<td>Test toleration setting<br><br>1.  Verify that cannot use Kubernetes tolerations for Longhorn setting<br>2.  Use &ldquo;key1=value1:NoSchedule; key2:NoExecute&rdquo; as toleration.<br>3.  Create a volume and attach it.<br>4.  Verify that cannot update toleration setting when any volume is attached<br>5.  Generate and write <code>data1</code> into the volume<br>6.  Detach the volume.<br>7.  Update setting <code>toleration</code> to toleration.<br>8.  Wait for all the Longhorn components to restart with new toleration<br>9.  Attach the volume again and verify the volume <code>data1</code>.<br>10.  Generate and write <code>data2</code> to the volume.<br>11.  Detach the volume.<br>12.  Clean the <code>toleration</code> setting.<br>13.  Wait for all the Longhorn components to restart with no toleration<br>14.  Attach the volume and validate <code>data2</code>.<br>15.  Generate and write <code>data3</code> to the volume</td>
<td>Kubernetes: Toleration</td>
</tr>
</tbody>
</table>
<h3 id="test-cases-using-kubectl">Test cases using kubectl</h3>
<table>
<thead>
<tr>
<th><strong>#</strong></th>
<th><strong>Test Case</strong></th>
<th><strong>Test Instructions</strong></th>
<th><strong>Expected Results</strong></th>
<th><strong>Automated ? / test name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Disable Volume Expansion for volumes dynamically provisioned by a new StorageClass<br><br>  <br><br><a href="https://github.com/longhorn/longhorn/blob/master/examples/storageclass.yaml">StorageClass example manifest</a></td>
<td>1.  Create a new StorageClass with <code>allowVolumeExpansion: false</code><br>2.  Create a PVC with using the new StorageClass</td>
<td>*   New Storage class should be created<br>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code><br>*   Volume expansion feature should be disabled for all Volumes using the new Storage Class</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Number of volume replicas volumes dynamically provisioned by a new StorageClass</td>
<td>1.  Create a new StorageClass, update<code>numberOfReplicas</code> parameter<br>2.  Create a PVC with using the new StorageClass</td>
<td>*   New Storage class should be created<br>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code><br>*   Volume number of replicas should match <code>numberOfReplicas</code> specified in storagecalss parameter</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>StorageClass <code>frombackup</code> parameter</td>
<td><strong>Prerequisite:</strong><br><br>*   Longhorn setting is set for Backup Target and Backup Target Credential Secret<br>*   Backup store should contain a previous volume backup<br>*   volume data checksum should be know at the time of volume backups (checksum#1)<br><br>1.  Create a StorageClass, and set <code>frombackup</code> parameter to volume backup URL in the backup store<br>2.  Create a PVC using the new StorageClass, and it’s size should be the original volume size<br>3.  Attach the new Volume to a node and check it’s data checksum</td>
<td>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code><br>*   Restore from backup process should be triggered<br>*   New volume should contain data restored from the backup, data checksum should match (checksum#1)</td>
<td>test_storage_class_from_backup</td>
</tr>
<tr>
<td>4</td>
<td>StorageClass <code>diskSelector</code> parameter</td>
<td><strong>Prerequisite:</strong><br><br>*   Longhorn Disks should have tags<br><br>1.  Create a new StorageClass, set <code>diskSelector</code> parameter<br>2.  Create a PVC with using the new StorageClass</td>
<td>*   New Storage class should be created<br>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code>, volume replicas should only scheduled to Disks with tags that match <code>diskSelector</code> parameter tags</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>StorageClass <code>nodeSelector</code> parameter</td>
<td><strong>Prerequisite:</strong><br><br>*   Longhorn Node should have tags<br><br>1.  Create a new StorageClass, set <code>nodeSelector</code> parameter<br>2.  Create a PVC with using the new StorageClass</td>
<td>*   New Storage class should be created<br>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code>, volume replicas should only scheduled to Nodes with tags that match <code>nodeSelector</code> parameter tags</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>StorageClass <code>recurringJobs</code> parameter</td>
<td>1.  Create a new StorageClass, set <code>recurringJobs</code> parameter<br>2.  Create a PVC with using the new StorageClass<br>3.  Create a pod that consumes the created PVC<br>4.  Check Volume recurring jobs</td>
<td>*   New Storage class should be created<br>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code> and attached to the pod<br>*   Volume should have recurring snapshots and backups matches ones specified in <code>recurringJobs</code> StorageClass parameter</td>
<td>test_statefulset_recurring_backup</td>
</tr>
<tr>
<td>7</td>
<td>StorageClass with <code>reclaimPolicy</code> parameter set to <code>Delete</code></td>
<td>1.  Create a new StorageClass, set <code>reclaimPolicy</code> parameter to <code>Delete</code><br>2.  Create a PVC with using the new StorageClass<br>3.  Delete the PVC</td>
<td>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code><br>*   Deleting PVC would trigger Volume delete</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>StorageClass with <code>reclaimPolicy</code> parameter set to <code>Retain</code></td>
<td>1.  Create a new StorageClass, set <code>reclaimPolicy</code> parameter to <code>Delete</code><br>2.  Create a PVC with using the new StorageClass<br>3.  Delete PVC<br>4.  Delete PV</td>
<td>*   Volume should be dynamically provisioned, it’s PV/PVC should be <code>Bound</code><br>*   Deleting PVC and PV will not delete longhorn volume.</td>
<td>test_kubernetes_status</td>
</tr>
<tr>
<td>9</td>
<td>Static provisioning using <code>Default Longhorn Static StorageClass Name</code> Setting</td>
<td>1.  Update <code>Default Longhorn Static StorageClass Name</code> setting, set a new StorageClass Name, StorageClass doesn’t have to exist or be created.<br>2.  Create a Volume<br>3.  From Longhorn, Create a PV/PVC for the volume<br>4.  Check created PV <code>persistentVolumeReclaimPolicy: Retain</code><br>5.  Create a pod consuming created PVC<br>6.  Delete the pod<br>7.  Delete PV<br>8.  Delete PVC</td>
<td>*   Volume should be created<br>*   Volume PV should be created using new StorageClass Name defined in <code>Default Longhorn Static StorageClass Name</code> setting<br>*   PVC should be consumed by the pod, volume should be accessible in the pod, write/read operations should work normally.<br>*   Deleting PV/PVC will not trigger volume delete.</td>
<td>test_pvc_creation_with_default_sc_set</td>
</tr>
</tbody>
</table>
<h3 id="additional-tests-to-be-executed-from-rancher">Additional Tests to be executed from Rancher</h3>
<table>
<thead>
<tr>
<th><strong>#</strong></th>
<th><strong>Scenario</strong></th>
<th><strong>Steps</strong></th>
<th><strong>Expected Results</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Storage Class: Create a Longhorn storage class</td>
<td><strong>Pre condition:</strong><br><br>*   Longhorn is deployed in the cluster<br><br>**Steps:**<br><br>1.  Go to cluster → Storage → Storage Classes<br>2.  Click on Add class<br>3.  Select Provisioner **Longhorn**<br>4.  Give in other required parameters including replica count.<br>5.  Click on **Save**.<br>6.  Verify **test-1** storage class is created<br>7.  Go to Cluster → Project (default) → Workloads<br>8.  Deploy a workload<br>9.  In the Volumes section → Add a New Volume Claim → Use a Storage Class to provision a new persistent volume → Select **test-1** from Storage class dropdown.<br>10.  Enter capacity and Name. Click on Define<br>11.  Enter Mount Point.<br>12.  Click on create workload<br>13.  Verify workload is created successfully.<br>14.  Volume gets attached to the pod in the workload<br>15.  Navigate to Longhorn UI.<br>16.  Verify user is able to view the volume attached to the workload in the UI<br>17.  Navigate to volume details page of the volume and Verify the replica count mentioned in Step 4 is available</td>
<td>*   Longhorn storage class should be created<br>*   Workload should be deployed with the volume mounted from the storage class<br>*   Verify volume is available on the Longhorn UI.<br>*   Verify the replica count is as mentioned during storage class creation.</td>
</tr>
<tr>
<td>2</td>
<td>Persistent Volume: Create a PV</td>
<td><strong>Pre condition:</strong><br><br>*   Longhorn is deployed in the cluster<br><br>**Steps:**<br><br>1.  Create a Volume in Longhorn UI <code>test-volume</code><br>2.  Go to cluster → Storage → Persistent Volumes<br>3.  Click on Add PV<br>4.  Select Volume Plugin **Longhorn**<br>5.  Give in other required parameters including replica count.<br>6.  Give in Volume Plugin - <code>test-volume</code> which an existing volume in longhorn<br>7.  Click on **Save**.<br>8.  Verify **test-1** PV is created<br>9.  Go to Cluster → Project (default) → Workloads<br>10.  Deploy a workload<br>11.  In the Volumes section → Add a New Volume Claim → Use an existing persistent volume → Select **test-1** from PV dropdown.<br>12.  Click on Define<br>13.  Enter Mount Point.<br>14.  Click on create workload<br>15.  Verify workload is created successfully.<br>16.  Volume gets attached to the pod in the workload<br>17.  Navigate to Longhorn UI.<br>18.  Verify user is able to view the volume attached to the workload in the UI<br>19.  Navigate to volume details page of the volume and Verify the replica count mentioned in Step 4 is available</td>
<td>*   Longhorn PV should be created<br>*   Workload should be deployed with the volume mounted from the PV<br>*   Verify volume is available on the Longhorn UI.<br>*   Verify the replica count is as mentioned during storage class creation.</td>
</tr>
<tr>
<td>3</td>
<td>Create Storage class in Rancher; From Longhorn create volumes from this storage class.</td>
<td><strong>Pre condition:</strong><br><br>*   Longhorn is deployed in the cluster<br><br>**Steps:**<br><br>1.  Go to cluster → Storage → Storage Classes<br>2.  Click on Add class<br>3.  Select Provisioner **Longhorn**<br>4.  Give in other required parameters including replica count.<br>5.  Click on **Save**.<br>6.  Verify **test-1** storage class is created<br>7.  Go to Longhorn UI<br>8.  In the Settings page for “Default Longhorn Static StorageClass Name”, give in the value: “test-1”<br>9.  Go to Volumes page, click on create volume.<br>10.  Create a volume name : v1<br>11.  Verify v1 is created<br>12.  using kubectl -<br>13.  kubectl get pv <volume-name> -o yaml<br>14.  Verify “storageClassName:” &mdash;&gt; test-1</td>
<td>*   Longhorn storage class should be created<br>*   Value of Default Longhorn Static StorageClass Name should be changed in the settings page<br>*   volume should be created in longhorn UI<br>*   “storageClassName:” value should be **test-1**</td>
</tr>
<tr>
<td>4</td>
<td>Create Storage Class using backup URL</td>
<td>1.  Create volume and PV/PVC/POD in Longhorn<br>2.  Write <code>test_data</code> into pod<br>3.  Create a snapshot and back it up. Get the backup URL<br>4.  Create a new StorageClass <code>longhorn-from-backup</code> in rancher and set backup URL.<br>5.  Use <code>longhorn-from-backup</code> to create a new PVC<br>6.  Wait for the volume to be created and complete the restoration.<br>7.  Create the pod using the PVC. Verify the data</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Create Storage class - by using different values for the input list of paramters</td>
<td><strong>Pre condition:</strong><br><br>*   Longhorn is deployed in the cluster<br><br>**Steps:**<br><br>1.  Go to cluster → Storage → Storage Classes<br>2.  Click on Add class<br>3.  Select Provisioner **Longhorn**<br>4.  Give in other required parameters.<br>5.  Click on **Save**.<br>6.  Use this storage class to create a PVC and deploy in a workload.<br>7.  Verify the parameters of the volume created.</td>
<td>Volume parameters should match the storage class paramaters.</td>
</tr>
<tr>
<td>6</td>
<td>StorageClass with <code>reclaimPolicy</code> parameter set to <code>Delete</code> - PVC from storage class</td>
<td><strong>Pre conditions:</strong><br><br>*   Create PVC from “Longhorn” storage class in rancher.<br>*   It will have a dynamic PV bound<br><br>**Steps**:<br><br>1.  &lsquo;Delete PVC from Rancher<br>2.  Verify PVC is deleted<br>3.  Verify PV bound to this PVC is deleted - Rancher → Cluster → Storage → PV<br>4.  Verify the volume(Dynamic PV) in Longhorn is deleted</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Volume/PV/PVC created in Longhorn</td>
<td><strong>Pre conditions:</strong><br><br>*   Create volume, PV, PVC in longhorn<br><br>**Steps:**<br><br>1.  &lsquo;Delete PVC from Rancher<br>2.  Verify PVC is deleted<br>3.  PV will NOT. be deleted but be in “released” state in Rancher UI<br>4.  Verify Volume does not get deleted</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>StorageClass with <code>reclaimPolicy</code> parameter set to <code>Retain</code> - PVC from storage class</td>
<td><strong>Pre conditions:</strong><br><br>*   Create PVC from “Longhorn” storage class in rancher.<br>*   It will have a dynamic PV bound<br><br>**Steps**:<br><br>1.  &lsquo;Delete PVC from Rancher<br>2.  Verify PVC is deleted<br>3.  Verify PV bound to this PVC is NOT deleted - Rancher → Cluster → Storage → PV<br>4.  Verify the volume(Dynamic PV) in Longhorn is NOT deleted</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>StorageClass with <code>reclaimPolicy</code> parameter set to <code>Retain</code> - Volume/PV/PVC created in Longhorn</td>
<td><strong>Pre conditions:</strong><br><br>*   Create volume, PV, PVC in longhorn<br><br>**Steps:**<br><br>1.  &lsquo;Delete PVC from Rancher<br>2.  Verify PVC is deleted<br>3.  PV will NOT. be deleted but be in “released” state in Rancher UI<br>4.  Verify Volume does not get deleted</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Power down node</td>
<td>1.  Power down<br>2.  Replica migrates<br>3.  Power back on<br>4.  Verify if the replicas in the node have been deleted</td>
<td>*   When a node is powered down, the replica is rebuilt on the 4th wrker node.<br>*   When the node is powered back on, and the replica on the powered down node is not available in Longhorn UI anymore, there is no data in <code>/var/lib/longhorn/replicas</code> folder in the powered on node.</td>
</tr>
<tr>
<td>11</td>
<td>Power down node with. Node tag/disk tag</td>
<td>1.  Add a node tag/disk tag<br>2.  Power down<br>3.  Replica cannot migrate<br>4.  Power back on<br>5.  Replica should get rebuilt on this node</td>
<td>*   When a node is powered down, the replica is rebuilt on the 4th wrker node.<br>*   When the node is powered back on, and the replica on the powered down node is not available in Longhorn UI anymore, there is no data in <code>/var/lib/longhorn/replicas</code> folder in the powered on node.<br>*   The new replica is rebuilt on a node which has a tag.</td>
</tr>
<tr>
<td>12</td>
<td>Drain a node</td>
<td>1.  Drain use case — drain a worker node <br>2.  Check if the State of the node reflects in the Longhorn UI —&gt; Node<br>3.  Verify if replica is rebuilt on another node? <br>4.  Verify if the pod migrates<br>5.  And the volume get migrated</td>
<td>All the components should be successfully drained.</td>
</tr>
<tr>
<td>13</td>
<td>kubectl - force drain</td>
<td>Using kubectl - force drain a node where the pod with the volume attached is available<br><br>Have snapshots before<br><br>Verify data after pod migrates</td>
<td>Volume attaches on the new pod<br><br>2 of the 3 replicas are in “Stopped” state - Caused replica rebuild.</td>
</tr>
<tr>
<td>14</td>
<td>Cordon a node</td>
<td>1.  Cordon state - cordon a worker node</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>Delete node where the pods/workload exists<br><br><strong>workload type: deployment</strong></td>
<td>Verify the pods migrate to another node and verify the volume also re attaches on the pod on the other node</td>
<td>*   Create a workload with volume attached on n1<br>*   write data to volume<br>*   Delete node n1<br>*   The workload gets reattached to another node n2.<br>*   The volume gets attached after a minute<br>*   The volume is accessible.<br>*   data is accessible</td>
</tr>
<tr>
<td>16</td>
<td>Power down node where the pods/workload exists<br><br><strong>workload type: deployment</strong></td>
<td>Verify the pods migrate to another node and verify the volume also re attaches on the pod on the other node</td>
<td>host A → Pod a – Unknown – &gt; Not able to unmount<br><br>host b → pod b - Creating – fails to attach here</td>
</tr>
<tr>
<td>17</td>
<td>Delete node where the pods/workload exists<br><br><strong>workload type: stateful set</strong></td>
<td>*   Create a workload, scale - 2 with volume attached on n1<br>*   write data to volume<br>*   Delete node n1, and n2</td>
<td>*   The workload gets reattached to another node n3 and n4.<br>*   The volume gets attached after sometime<br>*   The volume is accessible.<br>*   data is accessible</td>
</tr>
<tr>
<td>18</td>
<td>Power down node where the pods/workload exists<br><br><strong>workload type: stateful set</strong></td>
<td>*   Create a workload, attach to a volume.<br>*   Write some data<br>*   Power down the node where the pod is running.</td>
<td>*   The pod should get recreated on another node.<br>*   The volume should get reattached.<br>*   The mount point should be accessible to read and write.</td>
</tr>
<tr>
<td>19</td>
<td>Delete worker node one by one</td>
<td></td>
<td>*   The volume should get reattach to healthy node.</td>
</tr>
<tr>
<td>20</td>
<td>Upgrade cluster - drain set - false</td>
<td>1.  In Rancher - upgrade a cluster by changing the max-pods value<br>2.  The cluster will go into “Updating” state<br>3.  Verify upgrade completes successfully</td>
<td>Upgrade should finish successfully</td>
</tr>
<tr>
<td>21</td>
<td>Upgrade cluster - drain set - true</td>
<td>1.  In Rancher - upgrade a cluster by changing the max-pods value<br>2.  The cluster will go into “Updating” state<br>3.  Verify upgrade completes successfully</td>
<td>Upgrade should finish successfully</td>
</tr>
</tbody>
</table>

    </article>
  </div>
</main>

    
    
  </body>
</html>
